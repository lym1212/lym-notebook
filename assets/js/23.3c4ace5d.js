(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{296:function(t,a,e){"use strict";e.r(a);var r=e(14),s=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"uniapp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#uniapp"}},[t._v("#")]),t._v(" Uniapp")]),t._v(" "),a("h2",{attrs:{id:"全局组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全局组件"}},[t._v("#")]),t._v(" 全局组件")]),t._v(" "),a("p",[t._v("App.vue中不能和vue一样添加template标签，如果要使用全局组件是就很不方便")]),t._v(" "),a("p",[t._v("例如：访客添加多租户逻辑时，需要在url后面加上激活码，web端采用路由拦截的方式，如果url错误时弹出一个不能关闭的提示弹框（我们使用的ui库有符合需求的组件可以直接调用）；访客使用的ui库没有符合需求的组件，需要自己封装，封装后不能在App.vue挂载，只能在每个页面加一个封装的组件并发送自定义事件控制显示和隐藏，然而使用路由拦截时，页面并没有加载，事件发送时组件还没有挂载，无法监听。")]),t._v(" "),a("p",[t._v("目前解决办法（页面较少）：每个页面加上这个组件，并且在onLoad里添加判断url是否正确的逻辑")])])}),[],!1,null,null,null);a.default=s.exports}}]);